![로고](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding4.png)
# 프딩 Pding

## 1. 프로젝트 개요 
  프딩(프레젠트 펀딩, Present Funding)은 원하는 선물을 등록하면 친구들이 그 금액을 채워주는 크라우드 펀딩 형태의 모바일 중접 웹 서비스입니다.
  기존 선물 문화의 문제를 해결하고, 사용자들이 더 나은 선물 경험을 즐길 수 있도록 돕기 위해 제작되었습니다.

## 2. 팀 구성 (3인)
  + **팀장 윤상희**: 기획, 프론트엔드 개발
  + **팀원 기나연**: UX/UI 디자인
  + **팀원 윤승권**: 프론트엔드, 백엔드 개발 

 ## 3. 개발 환경 및 기술
  + **협업** :     Figma, Notion, Git, Swagger
  + **언어** :     Java(jdk 17.), html/css, javascript
  + **FE** :       React, Nginx
  + **BE** :       Spring Boot(3.3.), JPA/Hibernate
  + **INFRA** :    MariaDB, Apache Tomcat(10.), AWS EC2, AWS S3, Docker, RabbitMQ
  + **API** :      KAKAO Oauth2, KAKAO PAY

 ## 4. 서비스 특징

  - **1. 높은 확장성**
    
    서비스 운영 과정에서 외부 기술들이 비용이나 성능 문제로 인한 교체에 대비하여 서비스에서 사용 할 외부
    기능들을 각각의 역할을 하는 추상체에 의존하게 하였다. 따라서 중간에 사용되는 서비스가 변경되더라도
    서비스 코드의 수정 없이, 추상체를 구현한 구체화된 클래스를 만들어 교체 할 수 있도록 코드를 작성하였다.

    
   - **2. 테스트 용이**
    
      테스트 시 테스트 목적에 집중된 테스트가 가능하도록 각각의 부가 기능들을 인터페이스로 추상화 시키고,
      테스트 시 빌더를 이용하여 테스트 목적에 맞도록 구체화된 테스트 대역들을 적절하게 조합한 서비스를 만들어서
      테스트하여 프레임워크나 외부 서비스에 크게 의존하지 않는 테스트를 작성하였다.


## 5. 문제 해결

  - **응답 속도 개선**
    
    1. **캐싱 최적화**
    
      초기 접근 : Redis를 활용하여 캐싱을 구현하고, Redisson의 RLock 및 Facade 패턴을 적용해 동시성 테스트를
      진행했다. 그러나 글로벌 캐시 특성상 직렬화/역직렬화 오버헤드와 네트워크 비용으로 인해 기대한 속도 향상이 나타
      나지 않았다.
      전환 : 모놀리스 환경에 적합한 로컬 캐시인 Caffeine을 도입하고, TTL(Time − To − Live) 설정을 통해 마감
      기한까지 데이터를 유지하여 데이터베이스 접근과 디스크 I/O를 줄였다

    2. **버퍼 최적화**
    
      초기 접근 : CAS 기반 비동기 큐를 사용하여 데이터베이스 쓰기 작업을 비동기화했으나, 서비스 비정상 종료 시
      데이터 유실 문제가 발생했다.
      전환 : RabbitMQ를 도입하여 데이터의 영속성을 보장했다. durable 속성을 활성화해 데이터를 디스크에
      저장함으로써 안정성을 확보했다.
    
    3. **쿼리 최적화**
    
      테스트용 더미 데이터를 추가하고, 조회 빈도가 높은 컬럼을 기준으로 단일 및 복합 인덱스를 설정하였다.또한
      프로파일링을 통해 현재뿐만 아니라 향후 대용량 데이터 처리에도 적합한 방식으로 인덱스를 구성하였다.
      마지막으로 홈 화면에서 사용되는 주요 쿼리의 정렬 과정을 제거하여 실행 속도를 단축시켰다.
      결과적으로 추가적인 RabbitMQ만을 도입하여, 단일 결제 요청 기준으로 약 100ms의 응답 속도에서
      약 50ms으로 약 두 배 가량의 응답 속도를 단축 시킬 수 있었다.

    
- **OSIV 문제 해결**
    
    Spring Filter에서 인증/인가 과정 중 JPA 엔티티를 조회할 때 Lazy Loading을 사용하는 엔티티가 OSIV
    (OpenSessionInView) 인터셉터 적용 전에 호출되어 LazyInitializationException이 발생했다.
    1. **Lazy Loading으로 선언된 속성을 Eagle Loading으로 변경**
        간단하게 Fetch 속성을 Eagle로 바꾸면 해결되지만 지연 로딩을 사용하지 못하는 성능 상 제일 좋지 않은 방법이었다.

    2. **OSIV 인터셉터를 필터로 변경하여 FilterProxy상단에 추가**
        커스텀 OSIV 필터를 만들어서 기존의 필터 앞에 설정하면 되는 간단한 방법이지만, DB 커넥션 의존성을
        줄이기 위해 다른 방법을 고려했다.

    3. **JPA 엔티티가 아닌 검증 과정에 필요한 속성만 있는 DTO로 데이터베이스에서 불러오기**
        검증 로직을 전체적으로 리팩토링하며, 일부 컬럼만 조회하여 DTO를반환하는 별도 쿼리를 작성해야 했다.
        많은 작업이 필요했지만, 장기적으로 DB 커넥션 의존성을 줄이고 성능을 향상시킬 수 있어 최종적으로 이
        방법을 선택했다.


- **단위 테스트**

    서비스가 초기에 데이터 중심으로 설계되어 각각의 도메인의 서비스를 단위 테스트 할 때 영속성 객체와 리포지토리에
    의존성이 높아서 단위 테스트에 어려움을겪었다.
    따라서 각각의 리포지토리 추상체를 구현한 테스트 대역인 Stub 리포지토리를 만들고, Stub 리포지토리 자체에서
    컬랙션을 이용한 저장소를 만들어 서비스 레이어에서 리포지토리에 CRUD 요청을 할 시 실제 데이터베이스 없이
    서비스 레이어의 검증에 집중하여 테스트 코드를 작성할 수 있었다.
    단일 인덱스로만 READ하는 것이 아니기 때문에 주로 List를 이용하여 저장소를 구현하였는데, READ나 UPDATE
    하는 과정에서 전체 데이터를 탐색해야 하므로 O(N)의 시간이 걸리지만, 단위 테스트라는 점을 감안하여 대용량의
    데이터가 아닌 최소한의 데이터로 검증하기 때문에 큰 문제가 되지 않았다.





## 7. ERD
![데이터베이스](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding3.png)

## 8. 결과물

![경진대회](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding6.png)
![과제전](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding7.png)

## 9. 링크
+ **프론트엔드**: <https://github.com/YoonSeungKwon/PdingFE>


+ **포트폴리오**: <https://sites.google.com/view/cau-artech/3-2/%EC%BA%A1%EC%8A%A4%ED%86%A4%EB%94%94%EC%9E%90%EC%9D%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B81/2023/%ED%94%84%EB%94%A9>
