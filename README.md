![로고](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding4.png)
# 프딩 Pding

## 1. 프로젝트 개요 
  프딩(프레젠트 펀딩, Present Funding)은 원하는 선물을 등록하면 친구들이 그 금액을 채워주는 크라우드 펀딩 형태의 모바일 중접 웹 서비스입니다.
  기존 선물 문화의 문제를 해결하고, 사용자들이 더 나은 선물 경험을 즐길 수 있도록 돕기 위해 제작되었습니다.

## 2. 팀 구성 (3인)
  + **팀장 윤상희**: 기획, 프론트엔드 개발
  + **팀원 기나연**: UX/UI 디자인
  + **팀원 윤승권**: 프론트엔드, 백엔드 개발 

 ## 3. 개발 환경 및 기술
  + **협업** :     Figma, Notion, Git, Swagger
  + **언어** :     Java(jdk 17.), html/css, javascript
  + **FE** :       React, Nginx
  + **BE** :       Spring Boot(3.3.), JPA/Hibernate
  + **DB** :       MariaDB, Redis
  + **SEVER** :    Apache Tomcat(10.), AWS EC2, AWS S3, Docker, RabbitMQ
  + **API** :      KAKAO Oauth2, KAKAO PAY
  + **MQ**  :      RabbitMQ

 ## 4. 서비스 특징

  - **객체지향적 설계**
    
    **1. 확장성**
    
    서비스가 운영되면서 데이터베이스나 스토리지 클라우드 등의 비용이나 성능 문제로 인한 마이그레이션에 대비하여 서비스 레이어에서 사용할 기능들을 **각각의 역할을 하는 추상체에 의존**하게 하였다.
     따라서 중간에 사용되는 서비스가 변경되더라도 **서비스 레이어의 직접적인 수정 없이, 추상체를 구현한 구체화된 클래스를 만들어 교체**하여 사용할 수 있도록 코드를 작성하였다.
    
    **2. 테스트**
    
    서비스를 테스트할 때 각각의 테스트 목적에 집중한 테스트가 가능하도록 각각의 기능들을 인터페이스로 추상화시키고, 테스트 시 빌더 패턴을 이용하여 **테스트 목적에 맞도록 구체화된 테스트 대역들을 적절하게 조합**한 서비스를 만들어서 테스트하여 **프레임워크나 외부 서비스에 크게 의존하지 않을 수 있는 테스트 코드**를 작성하였다.
    
- **응답 속도**
    
    서비스 특성상 펀딩글이 작성되는 시간이 몰려있고, 펀딩이 등록되면 **결제 요청이 집중** 될 가능성이 높기 때문에 여러가지 방법을 통하여 응답 시간을 단축시켰다.
    
    **1. 캐싱 최적화**
    
    - **초기 접근:** Redis를 활용해 캐싱을 구현하고, Redisson의 RLock 및 Facade 패턴을 사용하여 동시성 테스트를 진행했다. 그러나 글로벌 캐시 특성상 직렬화/역직렬화 오버헤드와 네트워크 비용으로 인해 기대한 속도 향상이 나타나지 않았다.
    - **전환:** 모놀리스 환경에 더 적합한 로컬 캐시로 전환하여 Caffeine 캐시를 도입했다. TTL(Time-To-Live) 설정을 통해 마감 기한까지 엔티티를 캐싱하여 데이터베이스 접근과 디스크 I/O를 줄였다.
    
    **2. 버퍼 최적화**
    
    - **초기 접근:** CAS 기반 비동기 큐를 사용해 데이터베이스 쓰기 작업을 비동기화했지만, 서비스 비정상 종료 시 데이터 유실 문제가 발생했다.
    - **전환:** RabbitMQ를 도입하여 데이터의 영속성을 보장했다. `durable` 속성을 활성화해 데이터를 디스크에 저장함으로써 안정성을 확보했다.
    
    **3. 쿼리 최적화**
    장기적, 전체적인 서비스 성능 개선에는 사용하는 쿼리 최적화 또한 필연적이므로 쿼리 최적화 또한 진행하였다.
    
    테스트 더미 데이터들을 추가한 뒤 각 쿼리에서 조회에 많이 사용되는 컬럼을 기준으로 단일, 복합 인덱스들 중 프로파일링 결과를 통하여 현재 뿐만 아니라 향후에 대용량 데이터 처리 시 유리한 방향으로 인덱스를 설정하여 홈에서 사용되는 메인 쿼리의 정렬 과정을 없애고,  전체 쿼리의 실행 속도를 감소 시킬 수 있었다.
    
    결과적으로 추가적인 RabbitMQ만을 도입하여, 단일 결제 요청 기준으로 약 100ms의 응답 속도에서 약 50ms으로 약 두 배 가량의 응답 속도를 단축 시킬 수 있었다.


## 5. 이슈

  - **OSIV 문제**
    
    JPA/Hibernate를 이용하여 ORM을 적용한 서비스에서 토큰 방식으로 Spring Filter단에서 진행되던 인증/인가 과정 중 JPA 엔티티를 불러와 검증하는 과정에 `LazyInitializationException`이 발생하였다. 
    이유는 Lazy Loading 속성을 사용하는 JPA 엔티티가 JPA사용시 default로 설정되는 OSIV 인터셉터보다 먼저 사용되었기 때문이다. 
    
    따라서 다음 해결 방법들을 고려하였다.
    
    1. **Lazy Loading으로 선언된 속성을 Eagle Loading으로 변경**
    
    1번 방법은 간단하게 Fetch속성만 Eagle로 바꾸면 해결되지만 성능 상 제일 좋지 않은 방법이므로 우선순위를 낮춰 다른 방법을 찾아보았다
    
    2. **OSIV 인터셉터를 필터로 변경하여 FilterProxy상단에 추가**
    
    2번 방법 또한 기존 코드 수정 없이 커스텀 OSIV 필터를 만들어서 기존의 필터 앞에 설정하면 되는 간단한 방법이지만, DB 커넥션에 의존적인 OSIV를 사용하는 것을 지양하기로 하여 우선순위를 낮춰 다른 
    방법을 찾아보았다. 
    ****
    3. **JPA 엔티티가 아닌 검증 과정에 필요한 속성만 있는 DTO로 데이터베이스에서 불러오기**
    
    3번 방법의 경우 인증 DTO를 만들고 인증 과정을 전체적으로 리팩토링하며 DTO를 조회하는 쿼리 또한 작성하여 추가해야 하므로 많은 작업이 요구되었지만, 장기적인 성능과 대용량 트래픽 시 DB커넥션에
    대한 의존성을 줄일 수 있기 때문에 3번 방법을 통하여 `LazyInitializationException`을 해결하였다.
    
- **테스트**
    
    서비스 초기에 데이터 중심으로 설계하였기 때문에 각각의 도메인의 **서비스 레이어를 단위 테스트** 할 때 **영속성 객체와 리포지토리에 의존성**이 높아서 단위 테스트하기에 어려움을 겪었다.
    
    따라서 각각의 리포지토리 추상체를 구현한 테스트 대역인 **Stub 리포지토리**를 만들고, Stub 리포지토리 자체에서 **컬랙션을 이용한 저장소**를 만들어 서비스 레이어에서 리포지토리에 CRUD 요청을 할 시 실제 데이터베이스 연결 없이 서비스 레이어의 검증에 집중하여 테스트 코드를 작성할 수 있었다.
    
    단일 인덱스로만 READ하는 것이 아니기 때문에 주로 **List**를 이용하여 저장소를 구현하였는데, READ나 UPDATE하는 과정에서 전체 데이터를 탐색해야 하므로 O(N)의 시간이 걸리지만, 단위 테스트라는 점을 감안하여 대용량의 데이터가 아닌 최소한의 데이터로 검증하기 때문에 큰 문제가 되지 않았다.





## 7. ERD
![데이터베이스](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding3.png)

## 8. 결과물

![경진대회](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding6.png)
![과제전](https://github.com/YoonSeungKwon/Capstone1/blob/master/pding7.png)

## 9. 링크
+ **프론트엔드**: <https://github.com/YoonSeungKwon/PdingFE>


+ **포트폴리오**: <https://sites.google.com/view/cau-artech/3-2/%EC%BA%A1%EC%8A%A4%ED%86%A4%EB%94%94%EC%9E%90%EC%9D%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B81/2023/%ED%94%84%EB%94%A9>
